---
layout: post
title: Path to painless upgrades in Ember
published: false
---

*Note: This post assumes some knowledge of JS features from ES2015*

*This is blog post is continuation to the my other blog post on [How to write a codemod][tutorial]*

### Introduction

After I wrote my last blog post on **How to write a codemod**, I was searching for problems that I can use for this blog post and I remembered about a blog post complaining the Ember 2.0 churn. I felt that codemods would have prevented some of the pain in the upgrading process. So, I wanted to write codemods for ember to show the community that, they can really benefit from codemods. But, the problem, I have absolutely zero knowledge of ember. But somehow, I landed on this [ember deprecations][ember-depr] page and I was immediately excited. It's because they gave the code before deprecation and after deprecation i.e, all we need to do is to write a codemod. I also felt a huge sigh of relief because I don't have to learn a new framework just to write a few codemods.    

In this blog post, we will codemods for two of such deprecations. The first one is extremely simple and second one is slightly more complex and tricky. Let's start!

### A little recap

In my previous blog post, I haven't summarized what we have learned about codemods. Let's quickly go over things we have learned so far.

The first step to write a code is to dump the both input and output code in [ASTExplorer][ast] and inspect it & identify the nodes you want to change. Only then start writing your codemod.

Codemod is essentially a function which takes `file` and `api` (jscodeshift API) as arguments and returns the transformed JavaScript code as the output. Inside our codemod function, first we convert our given JavaScript code into AST. We now, find all the node we wants to modify and apply the corresponding modifications on them. Once we are done, we convert the modified AST back into JavaScript code.

#### API summary

Note: `j` simply refers to `api.jscodeshift` if you have forgot.

These are [jscodeshift][jscodeshift] API that we have learnt so far.  

- Pascal case version of node type (for example `j.Identifier`) is used to check the type of node

- Camel case version of node type (for example `j.identifier`) is used to construct new nodes  

- `j(...)` takes the source of file and converts it into an AST

- `.find(...)` finds particular nodes in the AST and returns a list of paths. jscodeshift doesn't use an array to represent these paths. Instead it uses custom `Collection` class to represents these paths and provides its own custom methods such as `map`, `filter`, `replaceWith` etc., In fact, the AST that is generated by `j(...)` is also a `Collection`.

  These are not documented anywhere so for now you have to read the jscodeshift's source to find all such methods. We will use a couple in this blogpost and they should be sufficient.

- `.replaceWith(...)` replace the node at a each path inside the Collection.

- `.toSource()` converts the transformed AST into JavaScript code.


### Problem 1

Let's look at the [first deprecation code][dep1] that we will transform.

```js
// Ember < 2.1

import layout from '../templates/some-thing-lol';

export default Ember.Component.extend({
  defaultLayout: layout
});

// Ember 2.1 and later

import layout from '../templates/some-thing-lol';

export default Ember.Component.extend({
  layout: layout
});

```

### Solution

The simplest solution is to replace `defaultLayout` identifier by `layout` identifier. But it may do false positives transformations. We avoid this problem by looking for some more context i.e, `defaultLayout` is key of an object literal and the object itself is an argument to `Ember.Component.extend` function call.

So, the algorithm will be as follows:

- Find all instances of `Identifier`'s whose name is `defaultLayout` and this will give us paths to all such nodes.

- Go to the path of parent node (`p.parent`) and check if it's a `Property` node and the `defaultLayout` is the key of this property. This also confirms `Property` node parent is an `ObjectExpression` node.

- Check if the parent of `ObjectExpression` node is `CallExpression` and the `CallExpression`'s callee is `Ember.Component.extend`.

- If path a satisfies these properties, then replace the `defaultLayout` identifier with `layout` identifier.

```js
export default function (file, api) {
  const j = api.jscodeshift

  const isProperty = p => {
    return (
      p.parent.node.type === 'Property' &&
      p.parent.node.key.type === 'Identifier' &&
      p.parent.node.key.name === 'defaultLayout'
    )
  }

  const checkCallee = node => {
    const types = (
      node.type === 'MemberExpression' &&
      node.object.type === 'MemberExpression' &&
      node.object.object.type === 'Identifier' &&
      node.object.property.type === 'Identifier' &&
      node.property.type === 'Identifier'
    )

    const identifiers = (
      node.object.object.name === 'Ember' &&
      node.object.property.name === 'Component' &&
      node.property.name === 'extend'
    )

    return types && identifiers
  }

  const isArgument = p => {
    if (p.parent.parent.parent.node.type === 'CallExpression') {
      const call = p.parent.parent.parent.node
      return checkCallee(call.callee)
    }
  }

  const replaceDefaultLayout = p => {
    p.node.name = 'layout'
    return p.node
  }

  return j(file.source)
    .find(j.Identifier, { name: 'defaultLayout' })
    .filter(isProperty)
    .filter(isArgument)
    .replaceWith(replaceDefaultLayout)
    .toSource();
}
```

There is not much here to explain. The code here feels a bit long but most of it is checking types of nodes and `Identifier`'s name. Just look at return value of our transform, it gives the gist of what the codemod is. Each line follows the steps we have described above with the exception of first and last line which are common to every codemod. `filter` method here behaves exactly similar to `Array.filter`.  

**Note**: I am trying to write the most efficient code but I am trying to write modular code. The emphasis here is on teaching you how to write the codemod you want. Writing the most optimal code is left to you, the reader, as an exercise.

Also I should mention to those people who may want to try out this codemod on their own ember codebase that this codemod may not be complete. The reason being you may have code which relies on the `defaultLayout` property in other places. So, you may want to extend this codemod if you achieve correct results.

### Problem 2

Here is the [second deprecation code][dep2] that we will transform.

```js
// Ember < 2.1  

export function initialize(container, application) {
  application.inject('route', 'service:session');
}

export default {
  name: 'inject-session',
  initialize: initialize
}

// Ember 2.1 and later

export function initialize(application) {
  application.inject('route', 'service:session');
}

export default {
  name: 'inject-session',
  initialize: initialize
}
```

The solution I had in my mind was find the `initialize` function declaration and see if `container` was being inside it and if not just remove that variable.  

While I was thinking about the problem, I wanted to find ember 2.0 codebase to apply previous transform. I came across a few repos in which I saw another pattern for ember initializers.

```js
export default {
  name: 'inject-session',
  initialize: function (container, application) {
    application.inject('route', 'service:session');
  }
}
```

I wanted to handle this case in my codemod. I wanted to handle the slightly pathetic case where the initialize function is named something else instead of `initialize`.

Although it may feel a bit overkill, this problem helped me understand that I knew nothing about jscodeshift. I went and read a lot of examples and jscodeshift's source to get understand how I can solve this problem. At the end, I got a few insights on how to write a codemod which is I want to share with you in this blog post.      

### Solution (Attempt 1)

The outline of my first solution is to find the object which has `name` & `initialize` keys and depending the type of value of `initialize` key we can apply a suitable transform. The case `initialize` key's value is a function seemed easier to handle.

This is my first half of the solution:

```js
export default function (file, api) {
  const j = api.jscodeshift;

  const hasKey = (object, key) => {
    const { properties } = object;
    return properties.some(property => property.key.name === key);
  }

  const transformArity = fnNode => {
    if (fnNode.params.length === 2) {
      if (j(fnNode.body).find(j.Identifier, { name: 'container' }).size() === 0) {
        fnNode.params = [ fnNode.params[1] ];
      }
    }
  }

  const changeArity = p => {
    const { node } = p
    if (hasKey(node, 'name') && hasKey(node, 'initialize')) {
      const [ initialize ] = node.properties.filter(property => property.key.name === 'initialize')

      if (initialize.value.type === 'FunctionExpression' || initialize.value.type === 'ArrowFunctionExpression') {
        transformArity(initialize.value)
      } else if (initialize.value.type === 'Identifier') {
        // todo  
      }
    }

    return p.node
  }

  return (
    j(file.source)
      .find(j.ObjectExpression)
      .replaceWith(changeArity)
      .toSource()
  )
}
```

**A quick tip**: Always read the source of codemod from the bottom to top, it usually makes more sense that way. This way you don't have to read through plethora of implementation details to understand the gist of it.


Let's try to understand the code we have here. In the return value of the codemod function, first we convert the file into an AST and find all the `ObjectExpression` nodes and then apply the `changeArity` function on each of them finally convert it back to JavaScript code. This part is pretty much the same thing we have been doing in out previous examples.

In the `changeArity` function, we are checking if the `ObjectExpression` node we have contains the keys `name` and `initialize` using the `hasKey` function. If it has both of them, then we look at the type of value of `initialize` key. If it's either a `FunctionExpression` or `ArrowFunctionExpression`, we then apply the `transformArity` function which will check if the `FunctionExpression` has two arguments and if `container` has been used or not in the function body.

Here, I hit my first road block trying to write the `transformArity` function. I didn't know how to count all instances of `container`. After reading a bit of examples, I realized you can call `j` with a node and it will return a `Collection` of that node then we can perform `find`, `filter` etc., on it. `Collection` has a `size` method which will return the no. of paths it has. With this information we are back on track. So, we need to create a `Collection` from the function body and find all `Identifier`'s with name `container` and check if that `Collection`'s size is 0.   

Now we will look at how to handle the other case where type of value of `initialize` key is an `Identifier`. First we need look up the name of the `Identifier` and then find the `FunctionDeclaration` node then apply `transformArity` function on that node.    

So, the question is how do I go to this `FunctionDeclaration` node. The best way I could think of is to go the root of your AST and search from there. So, you have to go to parent node check if it has a parent node or not. If not then it is the root of AST otherwise go it's parent and check again. Although the idea seemed okay, I wanted to find an easier way to get to the root. After some struggle, I found the solution in one of the transforms in [react-codemod][react-codemod] repo. I will now present a very simplified version of it.

```js
export default function (file, api) {
  const j = api.jscodeshift;
  const root = j(file.source);

  // Some methods here

  const didTransform1 = root.find(...).replaceWith(...).size()

  const didTransform2 = root.find(...).replaceWith(...).size()

  if (didTransform1 + didTransform2 > 0) {
    return root.toSource();
  }

  return null
}
```
  

### Solution (Attempt 2)



[tutorial]: https://vramana.github.io/blog/2015/12/21/codemod-tutorial/
[ast]: http://astexplorer.net/
[ember-depr]: http://emberjs.com/deprecations/v2.x/
[jscodeshift]: https://github.com/facebook/jscodeshift
[dep1]: http://emberjs.com/deprecations/v2.x/#toc_ember-component-defaultlayout
[dep2]: http://emberjs.com/deprecations/v2.x/#toc_initializer-arity
[initial-sol]: https://github.com/vramana/ember-codemod/blob/dae24c2b0f1d34a08b332784aa96ade505c774fe/transforms/default-layout.js
[react-codemod]: https://github.com/reactjs/react-codemod

---
layout: post
title: Codemods: Path to painless upgrades in Ember
published: false
---

*Note: This post assumes some knowledge of JS features from ES2015*

*This is blog post is continuation to the my other blog post on [How to write a codemod][tutorial]*

### Introduction

After I wrote my last blog post on **How to write a codemod**, I was searching for problems that I can use for this blog post and I remembered about a blog post complaining the Ember 2.0 churn. I felt that codemods would have prevented some of the pain in the upgrading process. So, I wanted to write codemods for ember to show the community that, they can really benefit from codemods. But, the problem, I have absolutely zero knowledge of ember. But somehow, I landed on this [ember deprecations][ember-depr] page and I was immediately excited. It's because they gave the code before deprecation and after deprecation i.e, all we need to do is to write a codemod. I also felt a huge sigh of relief because I don't have to learn a new framework just to write a few codemods.    

In this blog post, we will codemods for two of such deprecations. The first one is extremely simple and second one is slightly more complex and tricky. Let's start!

### A little recap

In my previous blog post, I haven't summarized what we have learned about codemods. Let's quickly go over things we have learned so far.

The first step to write a code is to dump the both input and output code in [ASTExplorer][ast] and inspect it & identify the nodes you want to change. Only then start writing your codemod.

Codemod is essentially a function which takes `file` and `api` (jscodeshift API) as arguments and returns the transformed JavaScript code as the output. Inside our codemod function, first we convert our given JavaScript code into AST. We now, find all the node we wants to modify and apply the corresponding modifications on them. Once we are done, we convert the modified AST back into JavaScript code.

#### API summary

Note: `j` simply refers to `api.jscodeshift` if you have forgot.

These are [jscodeshift][jscodeshift] API that we have learnt so far.  

- Pascal case version of node type (for example `j.Identifier`) is used to check the type of node

- Camel case version of node type (for example `j.identifier`) is used to construct new nodes  

- `j(...)` takes the source of file and converts it into an AST

- `.find(...)` finds particular nodes in the AST and returns a list of paths. jscodeshift doesn't use an array to represent these paths. Instead it uses custom `Collection` class to represents these paths and provides its own custom methods such as `map`, `filter`, `replaceWith` etc., In fact, the AST that is generated by `j(...)` is also a `Collection`.

  These are not documented anywhere so for now you have to read the jscodeshift's source to find all such methods. We will use a couple in this blogpost and they should be sufficient.

- `.replaceWith(...)` replace the node at a each path inside the Collection.

- `.toSource()` converts the transformed AST into JavaScript code.


### Problem 1

Let's look at the [first deprecation code][dep1] that we will transform.

```js
// Ember < 2.1

import layout from '../templates/some-thing-lol';

export default Ember.Component.extend({
  defaultLayout: layout
});

// Ember 2.1 and later

import layout from '../templates/some-thing-lol';

export default Ember.Component.extend({
  layout: layout
});

```

### Solution

The simplest solution is to replace `defaultLayout` identifier by `layout` identifier. But it may do false positives transformations. We avoid this problem by looking for some more context i.e, `defaultLayout` is key of an object literal and the object itself is an argument to `Ember.Component.extend` function call.

So, the algorithm will be as follows:

- Find all instances of `Identifier`'s whose name is `defaultLayout` and this will give us paths to all such nodes.

- Go to the path of parent node (`p.parent`) and check if it's a `Property` node and the `defaultLayout` is the key of this property. This also confirms `Property` node parent is an `ObjectExpression` node.

- Check if the parent of `ObjectExpression` node is `CallExpression` and the `CallExpression`'s callee is `Ember.Component.extend`.

- If path a satisfies these properties, then replace the `defaultLayout` identifier with `layout` identifier.

```js
export default function (file, api) {
  const j = api.jscodeshift

  const isProperty = p => {
    return (
      p.parent.node.type === 'Property' &&
      p.parent.node.key.type === 'Identifier' &&
      p.parent.node.key.name === 'defaultLayout'
    )
  }

  const checkCallee = node => {
    const types = (
      node.type === 'MemberExpression' &&
      node.object.type === 'MemberExpression' &&
      node.object.object.type === 'Identifier' &&
      node.object.property.type === 'Identifier' &&
      node.property.type === 'Identifier'
    )

    const identifiers = (
      node.object.object.name === 'Ember' &&
      node.object.property.name === 'Component' &&
      node.property.name === 'extend'
    )

    return types && identifiers
  }

  const isArgument = p => {
    if (p.parent.parent.parent.node.type === 'CallExpression') {
      const call = p.parent.parent.parent.node
      return checkCallee(call.callee)
    }
  }

  const replaceDefaultLayout = p => {
    p.node.name = 'layout'
    return p.node
  }

  return j(file.source)
    .find(j.Identifier, { name: 'defaultLayout' })
    .filter(isProperty)
    .filter(isArgument)
    .replaceWith(replaceDefaultLayout)
    .toSource();
}
```

There is not much here to explain. The code here feels a bit long but most of it is checking types of nodes and `Identifier`'s name. Just look at return value of our transform, it gives the gist of what the codemod is. Each line follows the steps we have described above with the exception of first and last line which are common to every codemod. `filter` method here behaves exactly similar to `Array.filter`.  

**Note**: I am trying to write the most efficient code but I am trying to write modular code. The emphasis here is on teaching you how to write the codemod you want. Writing the most optimal code is left to you, the reader, as an exercise.

Also I should mention to those people who may want to try out this codemod on their own ember codebase that this codemod may not be complete. The reason being you may have code which relies on the `defaultLayout` property in other places. So, you may want to extend this codemod if you achieve correct results.

### Problem 2

Here is the [second deprecation code][dep2] that we will transform.

```js
// Ember < 2.1  

export function initialize(container, application) {
  application.inject('route', 'service:session');
}

export default {
  name: 'inject-session',
  initialize: initialize
}

// Ember 2.1 and later

export function initialize(application) {
  application.inject('route', 'service:session');
}

export default {
  name: 'inject-session',
  initialize: initialize
}
```

The solution I had in my mind was find the `initialize` function declaration and see if `container` was being inside it and if not just remove that variable.  

While I was thinking about the problem, I wanted to find ember 2.0 codebase to apply previous transform. I came across a few repos in which I saw another pattern for ember initializers.

```js
export default {
  name: 'inject-session',
  initialize: function (container, application) {
    application.inject('route', 'service:session');
  }
}
```

I wanted to handle this case in my codemod. I wanted to handle the slightly pathetic case where the initialize function is named something else instead of `initialize`.

Although it may feel a bit overkill, this problem helped me understand that I knew nothing about jscodeshift. I went and read a lot of examples and jscodeshift's source to get understand how I can solve this problem. At the end, I got a few insights on how to write a codemod which is I want to share with you in this blog post.      

### Solution (Attempt 1)

The outline of my first solution is to find the object which has `name` & `initialize` keys and depending the type of value of `initialize` key we can apply a suitable transform. The case `initialize` key's value is a function seemed easier to handle.

This is my first half of the solution:

```js
export default function (file, api) {
  const j = api.jscodeshift

  const hasKey = (object, key) => {
    const { properties } = object
    return properties.some(property => property.key.name === key)
  }

  const transformArity = fnNode => {
    if (fnNode.params.length === 2) {
      if (j(fnNode.body).find(j.Identifier, { name: 'container' }).size() === 0) {
        fnNode.params = [ fnNode.params[1] ]
      }
    }
  }

  const changeArity = p => {
    const { node } = p
    if (hasKey(node, 'name') && hasKey(node, 'initialize')) {
      const [ initialize ] = node.properties.filter(property => property.key.name === 'initialize')

      if (initialize.value.type === 'FunctionExpression') {
        transformArity(initialize.value)
      } else if (initialize.value.type === 'Identifier') {
        // todo  
      }
    }

    return p.node
  }

  return (
    j(file.source)
      .find(j.ObjectExpression)
      .replaceWith(changeArity)
      .toSource()
  )
}
```

**A quick tip**: Always read the source of codemod from the bottom to top, it usually makes more sense that way. This way you don't have to read through plethora of implementation details to understand the gist of it.

**Note:** Arity is defined as the number of arguments of that given function accepts.

Let's try to understand the code we have here. In the return value of the codemod function, first we convert the file into an AST and find all the `ObjectExpression` nodes and then apply the `changeArity` function on each of them finally convert it back to JavaScript code. This part is pretty much the same thing we have been doing in out previous examples.

In the `changeArity` function, we are checking if the `ObjectExpression` node we have contains the keys `name` and `initialize` using the `hasKey` function. If it has both of them, then we look at the type of value of `initialize` key. If it's either a `FunctionExpression`, we then apply the `transformArity` function which will check if the `FunctionExpression` has two arguments and if `container` has been used or not in the function body.

Here, I hit my first road block trying to write the `transformArity` function. I didn't know how to count all instances of `container`. After reading a bit of examples, I realized you can call `j` with a node and it will return a `Collection` of that node then we can perform `find`, `filter` etc., on it. `Collection` has a `size` method which will return the no. of paths it has. With this information we are back on track. So, we need to create a `Collection` from the function body and find all `Identifier`'s with name `container` and check if that `Collection`'s size is 0.   

Now we will look at how to handle the other case where type of value of `initialize` key is an `Identifier`. First we need look up the name of the `Identifier` and then find the `FunctionDeclaration` node then apply `transformArity` function on that node. That's it we are done because we already handled logic to transform the arity of the function and all we needed to do was to find where our function is.

So, the question is how do I go to this `FunctionDeclaration` node. The best way I could think of is to go the root of your AST and search from there. So, you have to go to parent node check if it has a parent node or not. If not then it is the root of AST otherwise go it's parent and check again. Although the idea seemed okay, I wanted to find an easier way to get to the root. After some struggle, I found the solution in one of the transforms in [react-codemod][react-codemod] repo. I will now present a very simplified version of it.

```js
export default function (file, api) {
  const j = api.jscodeshift;
  const root = j(file.source);

  // Some methods here

  const didTransform1 = root.find(...).replaceWith(...).size()

  const didTransform2 = root.find(...).replaceWith(...).size()

  if (didTransform1 + didTransform2 > 0) {
    return root.toSource();
  }

  return null
}
```

There are several ideas that presented in this short piece. But we will not right away delve into all of them right away. Let's just look at the most important one of them.

In the third line, `j(file.source)` is declared as `root`. As we have discussed, `j` when used a function returns a `Collection` and this time it's a collection that contains the entire program.

This solves of our problem of finding the `FunctionDeclaration` node because you can simply do `root.find(j.FunctionDeclaration)`. There is absolutely no need to write any recursive functions to get to the root. Voila! We can get back to solving our main problem.

This is what the final code looks like:

```js
export default function (file, api) {
  const j = api.jscodeshift
  const root = j(file.source)

  const hasKey = (object, key) => {
    const { properties } = object
    return properties.some(property => property.key.name === key)
  }

  const transformArity = fnNode => {
    if (fnNode.params.length === 2) {
      if (j(fnNode.body).find(j.Identifier, { name: 'container' }).size() === 0) {
        fnNode.params = [ fnNode.params[1] ]
      }
    }
  }

  const changeArity = p => {
    const { node } = p
    if (hasKey(node, 'name') && hasKey(node, 'initialize')) {
      const [ initialize ] = node.properties.filter(property => property.key.name === 'initialize')

      if (initialize.value.type === 'FunctionExpression') {
        transformArity(initialize.value)
      } else if (initialize.value.type === 'Identifier') {

        root.find(j.FunctionDeclaration, { id : { name:  initialize.value.name } })
          .replaceWith(p => {
            transformArity(p.node)
            return p.node;
          })
      }
    }

    return p.node
  }

  return (
    root.find(j.ObjectExpression)
      .replaceWith(changeArity)
      .toSource()
  )
}
```

All I did here was to replace the TODO block with some code and the rest is same. We actually didn't write much code this time. Let's try to understand it.

We started here with a familiar `root.find(j.FunctionDeclaration, ...)` call & the other argument is just to find the function with correct name and this find us path of the function we need. Then we are calling `.replaceWith(...)` to change the arity of the function that fits our description using previously defined `transformArity` function. Some here may say "Hey! wait a second. Are you trying to pull a fast one over me?" Actually no, I actually struggled quite a lot for writing these few lines.

We are actually inside a transformation call already and we are invoking another transformation call. It is a non-trivial idea but all we are doing is mutating AST within `root` Collection. This is first time I realized that I was mutating `root` AST, I was unhappy because I love functional programming and strongly try to not mutate data. If we are not mutating, both the transformations would end up creating two different AST's but we want to change same AST so we mutate it. I kind of disliked the API at this point. Anyway, let's get back to matter at hand.

After mutating ( transforming the function's arity ), we just stop there and  wait till we get out of the outer transformation call and covert the `root` back into JavaScript using `.toSource` method on the `Collection`.

Although I have solved the problem, I was not satisfied. The reason was `changeArity` didn't look clean at all and it was doing too much stuff. I wanted a better arrange the logic in a better way. And thats where I used the ideas in the above snippet again.       

### Solution (Attempt 2)

I am just re-pasting the above snippet for the sake of convenience. Let's dive more into it this time.

```js
export default function (file, api) {
  const j = api.jscodeshift;
  const root = j(file.source);

  // Some methods here

  const didTransform1 = root.find(...).replaceWith(...).size()

  const didTransform2 = root.find(...).replaceWith(...).size()

  if (didTransform1 + didTransform2 > 0) {
    return root.toSource();
  }

  return null
}
```

Here, I treat `root.find(...).replaceWith(...)` as a single transform. If you look at the above snippet, we are doing to two transforms. This pattern is immensely useful when your codemod has to deal with multiple styles of writing the same code like the case we are currently dealing with. The `.size()` calls at the end give no. of paths that have transformed in your transformation. The `didTransform1` and `didTransform2` variables capture total no. of paths that involved in the whole transformation. If their sum is zero, then there is not point in coverting unmodified AST to JavaScript, we can just leave the file as is and so we return `null` instead the `root.toSource()` to notify **jscodeshift**  that we haven't changed anything. These things are not necessary to write a codemod but it kind of hints at difference in the way the an amateur and an expert thinks.


Anyway before going into the second solution, I will introduce one last **jscodeshift** API. This API allows us to add custom methods (that are built on top of more primitive methods) on the `Collection`'s prototype so you use use these methods on `Collection`s as if they were normal methods. These are called Extensions. Here is how you do it.

```js
j.registerMethods({
  customMethod() {
    return this.find().... // some primitive methods
  }
})

// Allows:
root.customMethod()
```

Don't worry if this didn't make too much sense to you, we will see some real code that will help you understand things. Instead of extending the `Collection`, you can simply write a function and   

In our problem, we have two different styles of code which we have to codemod, one where `initialize` is an `Identifier` node and the other where it's a `FunctionExpression` node. So, the idea is to solve them independently using didTransform pattern (I just made this up) we just saw.  

This is what the final code looks like:

```js
export default function (file, api) {
  const j = api.jscodeshift
  const root = j(file.source)

  const transformArity = node => {
    if (node.params.length === 2) {
      if (j(node.body).find(j.Identifier, { name: node.params[0].name }).size() === 0) {
        node.params = [ node.params[1] ]
      }
    }
  }

  const hasKey = (object, key) => {
    const { properties } = object
    return properties.some(property => property.key.name === key)
  }

  const isIntializer = p => {
    return hasKey(p.node, 'name') && hasKey(p.node, 'initialize')
  }

  const findInitialize = p => {
    const { properties } = p.node
    const [ initialize ] = properties.filter(property => property.key.name === 'initialize')

    return initialize
  }

  const isIntializeMethod = p => findInitialize(p).value.type === 'FunctionExpression'

  const isIntializeIdentifier = p => findInitialize(p).value.type = 'Identifier'

  const changeMethod = p => {
    const method = findInitialize(p).value
    transformArity(method)

    return p.node
  }

  const changeIdentifierDeclaration = p => {
    const name = findInitialize(p1).value.name
    root.find(j.FunctionDeclaration, { id : { name } }).replaceWith(p => {
      transformArity(p.node)
      return p.node
    })

    return p.node
  }

  j.registerMethods({
    findInitializeMethod() {
      return (
        this.find(j.ObjectExpression)
          .filter(isIntializer)
          .filter(isIntializeMethod)
      )
    },
    findInitializeIdentifier() {
      return (
        this.find(j.ObjectExpression)
          .filter(isIntializer)
          .filter(isIntializeIdentifier)
      )
    }
  })

  const didTransform1 = root.findInitializeMethod().replaceWith(changeMethod).size()

  const didTransform2 = root.findInitializeIdentifier().replaceWith(changeIdentifierDeclaration).size()

  if (didTransform1 + didTransform2 > 0) {
    return root.toSource();
  }

  return null
}
```

This looks a lot longer than the previous solution but don't worry you have already seen most it and the real difference lies in the organization of the code.

Start reading the code from bottom to top. First thing to notice is using the didTransform pattern, we divided the transform into two sub-transforms which are simpler to reason about (Divide and Conquer FTW!!).

Without reading the implementation details lets look at what `didTransform1` and `didTransform2` are doing. The `didTransform1` handles the case where `initialize` is a `FunctionExpression` node and `didTransform2` handles the case where `initialize` is an `Identifier` node. Here,`findInitializeMethod` and `findInitializeIdentifier` are extensions which return the path of the `ObjectExpression`'s that have `initialize` defined as `FunctionExpression` and `Identifier` respectively. We transform both collection of paths using `changeMethod` and `changeIdentifierDeclaration` functions respectively. Then we see if the anything changed and convert the AST to JavaScript if something changes.

The implementation of `findInitializeMethod` is make a collection of `ObjectExpression`'s and filter the Initializer objects and check if the value of `initialize` key is actually a `FunctionExpression`. The implementation of `findInitializeIdentifier` is similar to `findInitializeMethod` except in the last step, instead of filtering `FunctionExpression` we filter `Identifier` nodes.

`changeMethod` and `changeIdentifierDeclaration` code is already presented in Solution 1. We just repackaged it under a different name here so I am not explaining it again. We are still doing a transformation call inside another transformation call in `changeIdentifierDeclaration`. I currently don't know any way around it. But the point of writing this approach is to learn a way to write transforms more **declaratively**. It's not completely declarative but it tries to be within it's limitations.


### Summary

Let's summarize quickly, the important things what we have learnt so far.

- By declaring `j(file.source)` as `root` let's you mutate the AST outside the scope of your current node.

- The didTransform pattern allows you to write two transforms in a single codemod.

That is all we have learned but I hoped to illustrate the need for these powerful ideas and how one can exploit these ideas to write a codemod. I think I tried my best to explain most of the concepts of codemods. Please go through the README of jscodeshift, it should not feel so alienistic. It will fill a few more things I have omitted here. You can now write codemods that you can use in your own project.

Currently, jscodeshift's documentation is in a poor state (not even an API reference). I hope to improve it in the coming weeks as much as possible. Also, I want to find way another way to avoid calling a transformation inside another transformation. I have recently heard about Lenses in [this talk][drboolean] probably they are meant to solve this kind of problem I don't know I have to experiment with them.

Coming back to the title of this post, I just named that way because I think it may attract more eyes on codemods for this long standing problem. Codemods by no means are silver bullet but they solve some trivial aspects in a very effective way.

Thanks for reading this till the end. I appreciate it. If you have any comments or feedback, tweet at [@_vramana][vramana]

[tutorial]: https://vramana.github.io/blog/2015/12/21/codemod-tutorial/
[ast]: http://astexplorer.net/
[ember-depr]: http://emberjs.com/deprecations/v2.x/
[jscodeshift]: https://github.com/facebook/jscodeshift
[dep1]: http://emberjs.com/deprecations/v2.x/#toc_ember-component-defaultlayout
[dep2]: http://emberjs.com/deprecations/v2.x/#toc_initializer-arity
[initial-sol]: https://github.com/vramana/ember-codemod/blob/dae24c2b0f1d34a08b332784aa96ade505c774fe/transforms/default-layout.js
[react-codemod]: https://github.com/reactjs/react-codemod
[drboolean]: https://www.youtube.com/watch?v=AvgwKjTPMmM
[vramana]: https://twitter.com/_vramana
